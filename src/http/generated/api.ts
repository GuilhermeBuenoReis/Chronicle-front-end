/**
 * Generated by orval v7.3.0 üç∫
 * Do not edit manually.
 * in-orbit
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import { http } from '../client';
export type UpdatedCheckboxFromTask404 = {
  message: string;
};

export type UpdatedCheckboxFromTask201UpdatedTask = {
  content: string;
  createAt: string;
  id: string;
  /** @nullable */
  is_completed: boolean | null;
  title: string;
};

export type UpdatedCheckboxFromTask201 = {
  updatedTask: UpdatedCheckboxFromTask201UpdatedTask;
};

export type UpdatedCheckboxFromTaskBody = {
  is_completed?: boolean;
};

export type UpdatedCheckboxFromTaskParams = {
id: string;
};

/**
 * @nullable
 */
export type CreateNoteByFolder201 = typeof CreateNoteByFolder201[keyof typeof CreateNoteByFolder201] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateNoteByFolder201 = {
  null: 'null',
} as const;

export type CreateNoteByFolderBody = {
  content: string;
  tags?: string;
  title: string;
};

export type CreateNoteByFolderParams = {
folderId: string;
};

export type GetNotesWithFolder200ResultItem = {
  content: string;
  createdAt: string;
  /** @nullable */
  folder_id: string | null;
  id: string;
  /** @nullable */
  tags: string | null;
  title: string;
};

export type GetNotesWithFolder200 = {
  result: GetNotesWithFolder200ResultItem[];
};

export type GetNotesWithFolderParams = {
folder_id: string;
};

export type GetFolders200ResultItem = {
  createdAt: string;
  id: string;
  name: string;
};

export type GetFolders200 = {
  result: GetFolders200ResultItem[];
};

export type DeleteTaskById400 = {
  message: string;
};

export type DeleteTaskById200 = {
  message: string;
};

export type DeleteTaskByIdParams = {
id: string;
};

export type UpdatedTaskById404 = {
  message: string;
};

export type UpdatedTaskById201UpdatedTask = {
  content: string;
  createAt: string;
  id: string;
  /** @nullable */
  is_completed: boolean | null;
  title: string;
};

export type UpdatedTaskById201 = {
  updatedTask: UpdatedTaskById201UpdatedTask;
};

export type UpdatedTaskByIdBody = {
  content?: string;
  is_completed?: boolean;
  title?: string;
};

export type UpdatedTaskByIdParams = {
id: string;
};

export type GetTasks200Item = {
  content: string;
  createAt: string;
  id: string;
  /** @nullable */
  is_completed: boolean | null;
  title: string;
};

export type CreateTask201Task = {
  content: string;
  createAt: string;
  id: string;
  /** @nullable */
  is_completed: boolean | null;
  title: string;
};

export type CreateTask201 = {
  message: string;
  task: CreateTask201Task;
};

export type CreateTaskBody = {
  content: string;
  is_completed: boolean;
  title: string;
};

export type DeleteNoteById400 = {
  message: string;
};

export type DeleteNoteById200 = {
  message: string;
};

export type DeleteNoteByIdParams = {
id: string;
};

export type UpdatedNote404 = {
  message: string;
};

export type UpdatedNote201UpdatedNote = {
  content: string;
  createdAt: string;
  id: string;
  /** @nullable */
  tags: string | null;
  title: string;
};

export type UpdatedNote201 = {
  updatedNote: UpdatedNote201UpdatedNote;
};

export type UpdatedNoteBody = {
  content?: string;
  tags?: string;
  title?: string;
};

export type UpdatedNoteParams = {
id: string;
};

export type FindNotesById404 = {
  message: string;
};

export type FindNotesById200Note = {
  content: string;
  createdAt: string;
  id: string;
  /** @nullable */
  tags: string | null;
  title: string;
};

export type FindNotesById200 = {
  note: FindNotesById200Note;
};

export type FindNotesByIdParams = {
id: string;
};

export type FindNotesByTags404 = {
  message: string;
};

export type FindNotesByTags200NoteItem = {
  content: string;
  createdAt: string;
  id: string;
  tag: string;
  title: string;
};

export type FindNotesByTags200 = {
  note: FindNotesByTags200NoteItem[];
};

export type FindNotesByTagsBody = {
  tags: string;
};

export type GetNotes200ResultItem = {
  content: string;
  createdAt: string;
  /** @nullable */
  folderId: string | null;
  id: string;
  /** @nullable */
  tags: string | null;
  title: string;
};

export type GetNotes200 = {
  result: GetNotes200ResultItem[];
};

/**
 * @nullable
 */
export type CreateNote201 = typeof CreateNote201[keyof typeof CreateNote201] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateNote201 = {
  null: 'null',
} as const;

export type CreateNoteBody = {
  content: string;
  tags?: string;
  title: string;
};

export type AuthenticateUserRoute201 = {
  token: string;
};

export type AuthenticateUserRouteBody = {
  email: string;
  password: string;
};

/**
 * @nullable
 */
export type GetUserByEmailAndPassword201 = typeof GetUserByEmailAndPassword201[keyof typeof GetUserByEmailAndPassword201] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUserByEmailAndPassword201 = {
  null: 'null',
} as const;

export type GetUserByEmailAndPasswordBody = {
  email: string;
  password: string;
};

/**
 * @nullable
 */
export type CreateUser201 = typeof CreateUser201[keyof typeof CreateUser201] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateUser201 = {
  null: 'null',
} as const;

export type CreateUserBody = {
  avatarUrl: string;
  email: string;
  name: string;
  password: string;
};

/**
 * @nullable
 */
export type CreateFolders201 = typeof CreateFolders201[keyof typeof CreateFolders201] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateFolders201 = {
  null: 'null',
} as const;

export type CreateFoldersBody = {
  name: string;
};

export type GetUserLevelAndExperience200 = {
  experience: number;
  experienceToNextLevel: number;
  level: number;
};

export type GetProfile200Profile = {
  avatarUrl: string;
  /** @nullable */
  email: string | null;
  id: string;
  /** @nullable */
  name: string | null;
};

export type GetProfile200 = {
  profile: GetProfile200Profile;
};

export type AuthenticateFromGithub201 = {
  token: string;
};

export type AuthenticateFromGithubBody = {
  code: string;
};

export type GetWeekSummary200SummaryGoalsPerDayItem = {
  completedAt: string;
  id: string;
  title: string;
};

/**
 * @nullable
 */
export type GetWeekSummary200SummaryGoalsPerDay = {[key: string]: GetWeekSummary200SummaryGoalsPerDayItem[]} | null;

export type GetWeekSummary200Summary = {
  completed: number;
  /** @nullable */
  goalsPerDay: GetWeekSummary200SummaryGoalsPerDay;
  /** @nullable */
  total: number | null;
};

export type GetWeekSummary200 = {
  summary: GetWeekSummary200Summary;
};

export type GetWeekSummaryParams = {
weekStartsAt?: string;
};

export type GetWeekPendingGoals200PendingGoalsItem = {
  completionCount: number;
  desiredWeeklyFrequency: number;
  id: string;
  title: string;
};

export type GetWeekPendingGoals200 = {
  pendingGoals: GetWeekPendingGoals200PendingGoalsItem[];
};

/**
 * @nullable
 */
export type CreateGoalCompletion201 = typeof CreateGoalCompletion201[keyof typeof CreateGoalCompletion201] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateGoalCompletion201 = {
  null: 'null',
} as const;

export type CreateGoalCompletionBody = {
  goalId: string;
};

/**
 * @nullable
 */
export type CreateGoals201 = typeof CreateGoals201[keyof typeof CreateGoals201] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateGoals201 = {
  null: 'null',
} as const;

export type CreateGoalsBody = {
  /**
   * @minimum 1
   * @maximum 7
   */
  desiredWeeklyFrequency: number;
  title: string;
};




type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


/**
 * Create a goal
 */
export const getCreateGoalsUrl = () => {


  return `http://localhost:3333/goals`
}

export const createGoals = async (createGoalsBody: CreateGoalsBody, options?: RequestInit): Promise<CreateGoals201> => {
  
  return http<Promise<CreateGoals201>>(getCreateGoalsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createGoalsBody,)
  }
);}




export const getCreateGoalsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGoals>>, TError,{data: CreateGoalsBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createGoals>>, TError,{data: CreateGoalsBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createGoals>>, {data: CreateGoalsBody}> = (props) => {
          const {data} = props ?? {};

          return  createGoals(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateGoalsMutationResult = NonNullable<Awaited<ReturnType<typeof createGoals>>>
    export type CreateGoalsMutationBody = CreateGoalsBody
    export type CreateGoalsMutationError = unknown

    export const useCreateGoals = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGoals>>, TError,{data: CreateGoalsBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof createGoals>>,
        TError,
        {data: CreateGoalsBody},
        TContext
      > => {

      const mutationOptions = getCreateGoalsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Complete a goal
 */
export const getCreateGoalCompletionUrl = () => {


  return `http://localhost:3333/completions`
}

export const createGoalCompletion = async (createGoalCompletionBody: CreateGoalCompletionBody, options?: RequestInit): Promise<CreateGoalCompletion201> => {
  
  return http<Promise<CreateGoalCompletion201>>(getCreateGoalCompletionUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createGoalCompletionBody,)
  }
);}




export const getCreateGoalCompletionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGoalCompletion>>, TError,{data: CreateGoalCompletionBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createGoalCompletion>>, TError,{data: CreateGoalCompletionBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createGoalCompletion>>, {data: CreateGoalCompletionBody}> = (props) => {
          const {data} = props ?? {};

          return  createGoalCompletion(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateGoalCompletionMutationResult = NonNullable<Awaited<ReturnType<typeof createGoalCompletion>>>
    export type CreateGoalCompletionMutationBody = CreateGoalCompletionBody
    export type CreateGoalCompletionMutationError = unknown

    export const useCreateGoalCompletion = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGoalCompletion>>, TError,{data: CreateGoalCompletionBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof createGoalCompletion>>,
        TError,
        {data: CreateGoalCompletionBody},
        TContext
      > => {

      const mutationOptions = getCreateGoalCompletionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get pending goals
 */
export const getGetWeekPendingGoalsUrl = () => {


  return `http://localhost:3333/pending-goals`
}

export const getWeekPendingGoals = async ( options?: RequestInit): Promise<GetWeekPendingGoals200> => {
  
  return http<Promise<GetWeekPendingGoals200>>(getGetWeekPendingGoalsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetWeekPendingGoalsQueryKey = () => {
    return [`http://localhost:3333/pending-goals`] as const;
    }

    
export const getGetWeekPendingGoalsQueryOptions = <TData = Awaited<ReturnType<typeof getWeekPendingGoals>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekPendingGoals>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWeekPendingGoalsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekPendingGoals>>> = ({ signal }) => getWeekPendingGoals({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWeekPendingGoals>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWeekPendingGoalsQueryResult = NonNullable<Awaited<ReturnType<typeof getWeekPendingGoals>>>
export type GetWeekPendingGoalsQueryError = unknown


export function useGetWeekPendingGoals<TData = Awaited<ReturnType<typeof getWeekPendingGoals>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekPendingGoals>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekPendingGoals>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWeekPendingGoals<TData = Awaited<ReturnType<typeof getWeekPendingGoals>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekPendingGoals>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekPendingGoals>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWeekPendingGoals<TData = Awaited<ReturnType<typeof getWeekPendingGoals>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekPendingGoals>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetWeekPendingGoals<TData = Awaited<ReturnType<typeof getWeekPendingGoals>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekPendingGoals>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWeekPendingGoalsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get week summary goals
 */
export const getGetWeekSummaryUrl = (params?: GetWeekSummaryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:3333/summary?${normalizedParams.toString()}` : `http://localhost:3333/summary`
}

export const getWeekSummary = async (params?: GetWeekSummaryParams, options?: RequestInit): Promise<GetWeekSummary200> => {
  
  return http<Promise<GetWeekSummary200>>(getGetWeekSummaryUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetWeekSummaryQueryKey = (params?: GetWeekSummaryParams,) => {
    return [`http://localhost:3333/summary`, ...(params ? [params]: [])] as const;
    }

    
export const getGetWeekSummaryQueryOptions = <TData = Awaited<ReturnType<typeof getWeekSummary>>, TError = unknown>(params?: GetWeekSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSummary>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWeekSummaryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekSummary>>> = ({ signal }) => getWeekSummary(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWeekSummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWeekSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof getWeekSummary>>>
export type GetWeekSummaryQueryError = unknown


export function useGetWeekSummary<TData = Awaited<ReturnType<typeof getWeekSummary>>, TError = unknown>(
 params: undefined |  GetWeekSummaryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSummary>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWeekSummary<TData = Awaited<ReturnType<typeof getWeekSummary>>, TError = unknown>(
 params?: GetWeekSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSummary>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWeekSummary<TData = Awaited<ReturnType<typeof getWeekSummary>>, TError = unknown>(
 params?: GetWeekSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSummary>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetWeekSummary<TData = Awaited<ReturnType<typeof getWeekSummary>>, TError = unknown>(
 params?: GetWeekSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSummary>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWeekSummaryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Authenticate user from Gitub code
 */
export const getAuthenticateFromGithubUrl = () => {


  return `http://localhost:3333/auth/github`
}

export const authenticateFromGithub = async (authenticateFromGithubBody: AuthenticateFromGithubBody, options?: RequestInit): Promise<AuthenticateFromGithub201> => {
  
  return http<Promise<AuthenticateFromGithub201>>(getAuthenticateFromGithubUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authenticateFromGithubBody,)
  }
);}




export const getAuthenticateFromGithubMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticateFromGithub>>, TError,{data: AuthenticateFromGithubBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof authenticateFromGithub>>, TError,{data: AuthenticateFromGithubBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticateFromGithub>>, {data: AuthenticateFromGithubBody}> = (props) => {
          const {data} = props ?? {};

          return  authenticateFromGithub(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticateFromGithubMutationResult = NonNullable<Awaited<ReturnType<typeof authenticateFromGithub>>>
    export type AuthenticateFromGithubMutationBody = AuthenticateFromGithubBody
    export type AuthenticateFromGithubMutationError = unknown

    export const useAuthenticateFromGithub = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticateFromGithub>>, TError,{data: AuthenticateFromGithubBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof authenticateFromGithub>>,
        TError,
        {data: AuthenticateFromGithubBody},
        TContext
      > => {

      const mutationOptions = getAuthenticateFromGithubMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get user profile
 */
export const getGetProfileUrl = () => {


  return `http://localhost:3333/profile`
}

export const getProfile = async ( options?: RequestInit): Promise<GetProfile200> => {
  
  return http<Promise<GetProfile200>>(getGetProfileUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetProfileQueryKey = () => {
    return [`http://localhost:3333/profile`] as const;
    }

    
export const getGetProfileQueryOptions = <TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProfileQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProfile>>> = ({ signal }) => getProfile({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProfileQueryResult = NonNullable<Awaited<ReturnType<typeof getProfile>>>
export type GetProfileQueryError = unknown


export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProfileQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get user experience and level
 */
export const getGetUserLevelAndExperienceUrl = () => {


  return `http://localhost:3333/profile/gamification`
}

export const getUserLevelAndExperience = async ( options?: RequestInit): Promise<GetUserLevelAndExperience200> => {
  
  return http<Promise<GetUserLevelAndExperience200>>(getGetUserLevelAndExperienceUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetUserLevelAndExperienceQueryKey = () => {
    return [`http://localhost:3333/profile/gamification`] as const;
    }

    
export const getGetUserLevelAndExperienceQueryOptions = <TData = Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserLevelAndExperienceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserLevelAndExperience>>> = ({ signal }) => getUserLevelAndExperience({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserLevelAndExperienceQueryResult = NonNullable<Awaited<ReturnType<typeof getUserLevelAndExperience>>>
export type GetUserLevelAndExperienceQueryError = unknown


export function useGetUserLevelAndExperience<TData = Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserLevelAndExperience>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserLevelAndExperience<TData = Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserLevelAndExperience>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserLevelAndExperience<TData = Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUserLevelAndExperience<TData = Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUserLevelAndExperienceQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a folder
 */
export const getCreateFoldersUrl = () => {


  return `http://localhost:3333/folder`
}

export const createFolders = async (createFoldersBody: CreateFoldersBody, options?: RequestInit): Promise<CreateFolders201> => {
  
  return http<Promise<CreateFolders201>>(getCreateFoldersUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createFoldersBody,)
  }
);}




export const getCreateFoldersMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFolders>>, TError,{data: CreateFoldersBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createFolders>>, TError,{data: CreateFoldersBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createFolders>>, {data: CreateFoldersBody}> = (props) => {
          const {data} = props ?? {};

          return  createFolders(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateFoldersMutationResult = NonNullable<Awaited<ReturnType<typeof createFolders>>>
    export type CreateFoldersMutationBody = CreateFoldersBody
    export type CreateFoldersMutationError = unknown

    export const useCreateFolders = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFolders>>, TError,{data: CreateFoldersBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof createFolders>>,
        TError,
        {data: CreateFoldersBody},
        TContext
      > => {

      const mutationOptions = getCreateFoldersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Create a folder
 */
export const getCreateUserUrl = () => {


  return `http://localhost:3333/user`
}

export const createUser = async (createUserBody: CreateUserBody, options?: RequestInit): Promise<CreateUser201> => {
  
  return http<Promise<CreateUser201>>(getCreateUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUserBody,)
  }
);}




export const getCreateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: CreateUserBody}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = CreateUserBody
    export type CreateUserMutationError = unknown

    export const useCreateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {data: CreateUserBody},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get user by email and passowrd
 */
export const getGetUserByEmailAndPasswordUrl = () => {


  return `http://localhost:3333/auth/find`
}

export const getUserByEmailAndPassword = async (getUserByEmailAndPasswordBody: GetUserByEmailAndPasswordBody, options?: RequestInit): Promise<GetUserByEmailAndPassword201> => {
  
  return http<Promise<GetUserByEmailAndPassword201>>(getGetUserByEmailAndPasswordUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      getUserByEmailAndPasswordBody,)
  }
);}




export const getGetUserByEmailAndPasswordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getUserByEmailAndPassword>>, TError,{data: GetUserByEmailAndPasswordBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof getUserByEmailAndPassword>>, TError,{data: GetUserByEmailAndPasswordBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getUserByEmailAndPassword>>, {data: GetUserByEmailAndPasswordBody}> = (props) => {
          const {data} = props ?? {};

          return  getUserByEmailAndPassword(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetUserByEmailAndPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof getUserByEmailAndPassword>>>
    export type GetUserByEmailAndPasswordMutationBody = GetUserByEmailAndPasswordBody
    export type GetUserByEmailAndPasswordMutationError = unknown

    export const useGetUserByEmailAndPassword = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getUserByEmailAndPassword>>, TError,{data: GetUserByEmailAndPasswordBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof getUserByEmailAndPassword>>,
        TError,
        {data: GetUserByEmailAndPasswordBody},
        TContext
      > => {

      const mutationOptions = getGetUserByEmailAndPasswordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Authenticate user
 */
export const getAuthenticateUserRouteUrl = () => {


  return `http://localhost:3333/auth/authenticate`
}

export const authenticateUserRoute = async (authenticateUserRouteBody: AuthenticateUserRouteBody, options?: RequestInit): Promise<AuthenticateUserRoute201> => {
  
  return http<Promise<AuthenticateUserRoute201>>(getAuthenticateUserRouteUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authenticateUserRouteBody,)
  }
);}




export const getAuthenticateUserRouteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticateUserRoute>>, TError,{data: AuthenticateUserRouteBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof authenticateUserRoute>>, TError,{data: AuthenticateUserRouteBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticateUserRoute>>, {data: AuthenticateUserRouteBody}> = (props) => {
          const {data} = props ?? {};

          return  authenticateUserRoute(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticateUserRouteMutationResult = NonNullable<Awaited<ReturnType<typeof authenticateUserRoute>>>
    export type AuthenticateUserRouteMutationBody = AuthenticateUserRouteBody
    export type AuthenticateUserRouteMutationError = unknown

    export const useAuthenticateUserRoute = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticateUserRoute>>, TError,{data: AuthenticateUserRouteBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof authenticateUserRoute>>,
        TError,
        {data: AuthenticateUserRouteBody},
        TContext
      > => {

      const mutationOptions = getAuthenticateUserRouteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Create a folder
 */
export const getCreateNoteUrl = () => {


  return `http://localhost:3333/note`
}

export const createNote = async (createNoteBody: CreateNoteBody, options?: RequestInit): Promise<CreateNote201> => {
  
  return http<Promise<CreateNote201>>(getCreateNoteUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createNoteBody,)
  }
);}




export const getCreateNoteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNote>>, TError,{data: CreateNoteBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createNote>>, TError,{data: CreateNoteBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNote>>, {data: CreateNoteBody}> = (props) => {
          const {data} = props ?? {};

          return  createNote(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateNoteMutationResult = NonNullable<Awaited<ReturnType<typeof createNote>>>
    export type CreateNoteMutationBody = CreateNoteBody
    export type CreateNoteMutationError = unknown

    export const useCreateNote = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNote>>, TError,{data: CreateNoteBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof createNote>>,
        TError,
        {data: CreateNoteBody},
        TContext
      > => {

      const mutationOptions = getCreateNoteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get week summary notes
 */
export const getGetNotesUrl = () => {


  return `http://localhost:3333/notes/summary`
}

export const getNotes = async ( options?: RequestInit): Promise<GetNotes200> => {
  
  return http<Promise<GetNotes200>>(getGetNotesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetNotesQueryKey = () => {
    return [`http://localhost:3333/notes/summary`] as const;
    }

    
export const getGetNotesQueryOptions = <TData = Awaited<ReturnType<typeof getNotes>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotes>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNotesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotes>>> = ({ signal }) => getNotes({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNotesQueryResult = NonNullable<Awaited<ReturnType<typeof getNotes>>>
export type GetNotesQueryError = unknown


export function useGetNotes<TData = Awaited<ReturnType<typeof getNotes>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotes>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNotes<TData = Awaited<ReturnType<typeof getNotes>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotes>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNotes<TData = Awaited<ReturnType<typeof getNotes>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotes>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetNotes<TData = Awaited<ReturnType<typeof getNotes>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotes>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNotesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get user by email and passowrd
 */
export const getFindNotesByTagsUrl = () => {


  return `http://localhost:3333/notes/find`
}

export const findNotesByTags = async (findNotesByTagsBody: FindNotesByTagsBody, options?: RequestInit): Promise<FindNotesByTags200> => {
  
  return http<Promise<FindNotesByTags200>>(getFindNotesByTagsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      findNotesByTagsBody,)
  }
);}




export const getFindNotesByTagsMutationOptions = <TError = FindNotesByTags404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof findNotesByTags>>, TError,{data: FindNotesByTagsBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof findNotesByTags>>, TError,{data: FindNotesByTagsBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof findNotesByTags>>, {data: FindNotesByTagsBody}> = (props) => {
          const {data} = props ?? {};

          return  findNotesByTags(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FindNotesByTagsMutationResult = NonNullable<Awaited<ReturnType<typeof findNotesByTags>>>
    export type FindNotesByTagsMutationBody = FindNotesByTagsBody
    export type FindNotesByTagsMutationError = FindNotesByTags404

    export const useFindNotesByTags = <TError = FindNotesByTags404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof findNotesByTags>>, TError,{data: FindNotesByTagsBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof findNotesByTags>>,
        TError,
        {data: FindNotesByTagsBody},
        TContext
      > => {

      const mutationOptions = getFindNotesByTagsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Find notes by id
 */
export const getFindNotesByIdUrl = (id: string,
    params: FindNotesByIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:3333/notes/${id}?${normalizedParams.toString()}` : `http://localhost:3333/notes/${id}`
}

export const findNotesById = async (id: string,
    params: FindNotesByIdParams, options?: RequestInit): Promise<FindNotesById200> => {
  
  return http<Promise<FindNotesById200>>(getFindNotesByIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getFindNotesByIdQueryKey = (id: string,
    params: FindNotesByIdParams,) => {
    return [`http://localhost:3333/notes/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getFindNotesByIdQueryOptions = <TData = Awaited<ReturnType<typeof findNotesById>>, TError = FindNotesById404>(id: string,
    params: FindNotesByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findNotesById>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindNotesByIdQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findNotesById>>> = ({ signal }) => findNotesById(id,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findNotesById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type FindNotesByIdQueryResult = NonNullable<Awaited<ReturnType<typeof findNotesById>>>
export type FindNotesByIdQueryError = FindNotesById404


export function useFindNotesById<TData = Awaited<ReturnType<typeof findNotesById>>, TError = FindNotesById404>(
 id: string,
    params: FindNotesByIdParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findNotesById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findNotesById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useFindNotesById<TData = Awaited<ReturnType<typeof findNotesById>>, TError = FindNotesById404>(
 id: string,
    params: FindNotesByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findNotesById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findNotesById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useFindNotesById<TData = Awaited<ReturnType<typeof findNotesById>>, TError = FindNotesById404>(
 id: string,
    params: FindNotesByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findNotesById>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useFindNotesById<TData = Awaited<ReturnType<typeof findNotesById>>, TError = FindNotesById404>(
 id: string,
    params: FindNotesByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findNotesById>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getFindNotesByIdQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * updated note
 */
export const getUpdatedNoteUrl = (id: string,
    params: UpdatedNoteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:3333/notes/update/${id}?${normalizedParams.toString()}` : `http://localhost:3333/notes/update/${id}`
}

export const updatedNote = async (id: string,
    updatedNoteBody: UpdatedNoteBody,
    params: UpdatedNoteParams, options?: RequestInit): Promise<UpdatedNote201> => {
  
  return http<Promise<UpdatedNote201>>(getUpdatedNoteUrl(id,params),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatedNoteBody,)
  }
);}




export const getUpdatedNoteMutationOptions = <TError = UpdatedNote404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatedNote>>, TError,{id: string;data: UpdatedNoteBody;params: UpdatedNoteParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof updatedNote>>, TError,{id: string;data: UpdatedNoteBody;params: UpdatedNoteParams}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatedNote>>, {id: string;data: UpdatedNoteBody;params: UpdatedNoteParams}> = (props) => {
          const {id,data,params} = props ?? {};

          return  updatedNote(id,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatedNoteMutationResult = NonNullable<Awaited<ReturnType<typeof updatedNote>>>
    export type UpdatedNoteMutationBody = UpdatedNoteBody
    export type UpdatedNoteMutationError = UpdatedNote404

    export const useUpdatedNote = <TError = UpdatedNote404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatedNote>>, TError,{id: string;data: UpdatedNoteBody;params: UpdatedNoteParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof updatedNote>>,
        TError,
        {id: string;data: UpdatedNoteBody;params: UpdatedNoteParams},
        TContext
      > => {

      const mutationOptions = getUpdatedNoteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get pending goals
 */
export const getDeleteNoteByIdUrl = (id: string,
    params: DeleteNoteByIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:3333/notes/delete/${id}?${normalizedParams.toString()}` : `http://localhost:3333/notes/delete/${id}`
}

export const deleteNoteById = async (id: string,
    params: DeleteNoteByIdParams, options?: RequestInit): Promise<DeleteNoteById200> => {
  
  return http<Promise<DeleteNoteById200>>(getDeleteNoteByIdUrl(id,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteNoteByIdMutationOptions = <TError = DeleteNoteById400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNoteById>>, TError,{id: string;params: DeleteNoteByIdParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNoteById>>, TError,{id: string;params: DeleteNoteByIdParams}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteNoteById>>, {id: string;params: DeleteNoteByIdParams}> = (props) => {
          const {id,params} = props ?? {};

          return  deleteNoteById(id,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteNoteByIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNoteById>>>
    
    export type DeleteNoteByIdMutationError = DeleteNoteById400

    export const useDeleteNoteById = <TError = DeleteNoteById400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNoteById>>, TError,{id: string;params: DeleteNoteByIdParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteNoteById>>,
        TError,
        {id: string;params: DeleteNoteByIdParams},
        TContext
      > => {

      const mutationOptions = getDeleteNoteByIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Create a task
 */
export const getCreateTaskUrl = () => {


  return `http://localhost:3333/task`
}

export const createTask = async (createTaskBody: CreateTaskBody, options?: RequestInit): Promise<CreateTask201> => {
  
  return http<Promise<CreateTask201>>(getCreateTaskUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createTaskBody,)
  }
);}




export const getCreateTaskMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTask>>, TError,{data: CreateTaskBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createTask>>, TError,{data: CreateTaskBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTask>>, {data: CreateTaskBody}> = (props) => {
          const {data} = props ?? {};

          return  createTask(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTaskMutationResult = NonNullable<Awaited<ReturnType<typeof createTask>>>
    export type CreateTaskMutationBody = CreateTaskBody
    export type CreateTaskMutationError = unknown

    export const useCreateTask = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTask>>, TError,{data: CreateTaskBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof createTask>>,
        TError,
        {data: CreateTaskBody},
        TContext
      > => {

      const mutationOptions = getCreateTaskMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get tasks
 */
export const getGetTasksUrl = () => {


  return `http://localhost:3333/task/summary`
}

export const getTasks = async ( options?: RequestInit): Promise<GetTasks200Item[]> => {
  
  return http<Promise<GetTasks200Item[]>>(getGetTasksUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetTasksQueryKey = () => {
    return [`http://localhost:3333/task/summary`] as const;
    }

    
export const getGetTasksQueryOptions = <TData = Awaited<ReturnType<typeof getTasks>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTasksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTasks>>> = ({ signal }) => getTasks({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTasksQueryResult = NonNullable<Awaited<ReturnType<typeof getTasks>>>
export type GetTasksQueryError = unknown


export function useGetTasks<TData = Awaited<ReturnType<typeof getTasks>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTasks>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTasks<TData = Awaited<ReturnType<typeof getTasks>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTasks>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTasks<TData = Awaited<ReturnType<typeof getTasks>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTasks<TData = Awaited<ReturnType<typeof getTasks>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTasksQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * updated task
 */
export const getUpdatedTaskByIdUrl = (id: string,
    params: UpdatedTaskByIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:3333/task/update/${id}?${normalizedParams.toString()}` : `http://localhost:3333/task/update/${id}`
}

export const updatedTaskById = async (id: string,
    updatedTaskByIdBody: UpdatedTaskByIdBody,
    params: UpdatedTaskByIdParams, options?: RequestInit): Promise<UpdatedTaskById201> => {
  
  return http<Promise<UpdatedTaskById201>>(getUpdatedTaskByIdUrl(id,params),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatedTaskByIdBody,)
  }
);}




export const getUpdatedTaskByIdMutationOptions = <TError = UpdatedTaskById404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatedTaskById>>, TError,{id: string;data: UpdatedTaskByIdBody;params: UpdatedTaskByIdParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof updatedTaskById>>, TError,{id: string;data: UpdatedTaskByIdBody;params: UpdatedTaskByIdParams}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatedTaskById>>, {id: string;data: UpdatedTaskByIdBody;params: UpdatedTaskByIdParams}> = (props) => {
          const {id,data,params} = props ?? {};

          return  updatedTaskById(id,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatedTaskByIdMutationResult = NonNullable<Awaited<ReturnType<typeof updatedTaskById>>>
    export type UpdatedTaskByIdMutationBody = UpdatedTaskByIdBody
    export type UpdatedTaskByIdMutationError = UpdatedTaskById404

    export const useUpdatedTaskById = <TError = UpdatedTaskById404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatedTaskById>>, TError,{id: string;data: UpdatedTaskByIdBody;params: UpdatedTaskByIdParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof updatedTaskById>>,
        TError,
        {id: string;data: UpdatedTaskByIdBody;params: UpdatedTaskByIdParams},
        TContext
      > => {

      const mutationOptions = getUpdatedTaskByIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete task
 */
export const getDeleteTaskByIdUrl = (id: string,
    params: DeleteTaskByIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:3333/task/delete/${id}?${normalizedParams.toString()}` : `http://localhost:3333/task/delete/${id}`
}

export const deleteTaskById = async (id: string,
    params: DeleteTaskByIdParams, options?: RequestInit): Promise<DeleteTaskById200> => {
  
  return http<Promise<DeleteTaskById200>>(getDeleteTaskByIdUrl(id,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteTaskByIdMutationOptions = <TError = DeleteTaskById400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTaskById>>, TError,{id: string;params: DeleteTaskByIdParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTaskById>>, TError,{id: string;params: DeleteTaskByIdParams}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTaskById>>, {id: string;params: DeleteTaskByIdParams}> = (props) => {
          const {id,params} = props ?? {};

          return  deleteTaskById(id,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTaskByIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTaskById>>>
    
    export type DeleteTaskByIdMutationError = DeleteTaskById400

    export const useDeleteTaskById = <TError = DeleteTaskById400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTaskById>>, TError,{id: string;params: DeleteTaskByIdParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteTaskById>>,
        TError,
        {id: string;params: DeleteTaskByIdParams},
        TContext
      > => {

      const mutationOptions = getDeleteTaskByIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get folder
 */
export const getGetFoldersUrl = () => {


  return `http://localhost:3333/folder/summary`
}

export const getFolders = async ( options?: RequestInit): Promise<GetFolders200> => {
  
  return http<Promise<GetFolders200>>(getGetFoldersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetFoldersQueryKey = () => {
    return [`http://localhost:3333/folder/summary`] as const;
    }

    
export const getGetFoldersQueryOptions = <TData = Awaited<ReturnType<typeof getFolders>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFoldersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFolders>>> = ({ signal }) => getFolders({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getFolders>>>
export type GetFoldersQueryError = unknown


export function useGetFolders<TData = Awaited<ReturnType<typeof getFolders>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFolders>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFolders<TData = Awaited<ReturnType<typeof getFolders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFolders>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFolders<TData = Awaited<ReturnType<typeof getFolders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFolders<TData = Awaited<ReturnType<typeof getFolders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFoldersQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get notes with folder
 */
export const getGetNotesWithFolderUrl = (params: GetNotesWithFolderParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:3333/notes/summary/?${normalizedParams.toString()}` : `http://localhost:3333/notes/summary/`
}

export const getNotesWithFolder = async (params: GetNotesWithFolderParams, options?: RequestInit): Promise<GetNotesWithFolder200> => {
  
  return http<Promise<GetNotesWithFolder200>>(getGetNotesWithFolderUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetNotesWithFolderQueryKey = (params: GetNotesWithFolderParams,) => {
    return [`http://localhost:3333/notes/summary/`, ...(params ? [params]: [])] as const;
    }

    
export const getGetNotesWithFolderQueryOptions = <TData = Awaited<ReturnType<typeof getNotesWithFolder>>, TError = unknown>(params: GetNotesWithFolderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotesWithFolder>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNotesWithFolderQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotesWithFolder>>> = ({ signal }) => getNotesWithFolder(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNotesWithFolder>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNotesWithFolderQueryResult = NonNullable<Awaited<ReturnType<typeof getNotesWithFolder>>>
export type GetNotesWithFolderQueryError = unknown


export function useGetNotesWithFolder<TData = Awaited<ReturnType<typeof getNotesWithFolder>>, TError = unknown>(
 params: GetNotesWithFolderParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotesWithFolder>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotesWithFolder>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNotesWithFolder<TData = Awaited<ReturnType<typeof getNotesWithFolder>>, TError = unknown>(
 params: GetNotesWithFolderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotesWithFolder>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotesWithFolder>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNotesWithFolder<TData = Awaited<ReturnType<typeof getNotesWithFolder>>, TError = unknown>(
 params: GetNotesWithFolderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotesWithFolder>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetNotesWithFolder<TData = Awaited<ReturnType<typeof getNotesWithFolder>>, TError = unknown>(
 params: GetNotesWithFolderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotesWithFolder>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNotesWithFolderQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create note by folder
 */
export const getCreateNoteByFolderUrl = (params: CreateNoteByFolderParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:3333/folder/note/create?${normalizedParams.toString()}` : `http://localhost:3333/folder/note/create`
}

export const createNoteByFolder = async (createNoteByFolderBody: CreateNoteByFolderBody,
    params: CreateNoteByFolderParams, options?: RequestInit): Promise<CreateNoteByFolder201> => {
  
  return http<Promise<CreateNoteByFolder201>>(getCreateNoteByFolderUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createNoteByFolderBody,)
  }
);}




export const getCreateNoteByFolderMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNoteByFolder>>, TError,{data: CreateNoteByFolderBody;params: CreateNoteByFolderParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createNoteByFolder>>, TError,{data: CreateNoteByFolderBody;params: CreateNoteByFolderParams}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNoteByFolder>>, {data: CreateNoteByFolderBody;params: CreateNoteByFolderParams}> = (props) => {
          const {data,params} = props ?? {};

          return  createNoteByFolder(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateNoteByFolderMutationResult = NonNullable<Awaited<ReturnType<typeof createNoteByFolder>>>
    export type CreateNoteByFolderMutationBody = CreateNoteByFolderBody
    export type CreateNoteByFolderMutationError = unknown

    export const useCreateNoteByFolder = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNoteByFolder>>, TError,{data: CreateNoteByFolderBody;params: CreateNoteByFolderParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof createNoteByFolder>>,
        TError,
        {data: CreateNoteByFolderBody;params: CreateNoteByFolderParams},
        TContext
      > => {

      const mutationOptions = getCreateNoteByFolderMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * updated task
 */
export const getUpdatedCheckboxFromTaskUrl = (params: UpdatedCheckboxFromTaskParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:3333/task/update/?${normalizedParams.toString()}` : `http://localhost:3333/task/update/`
}

export const updatedCheckboxFromTask = async (updatedCheckboxFromTaskBody: UpdatedCheckboxFromTaskBody,
    params: UpdatedCheckboxFromTaskParams, options?: RequestInit): Promise<UpdatedCheckboxFromTask201> => {
  
  return http<Promise<UpdatedCheckboxFromTask201>>(getUpdatedCheckboxFromTaskUrl(params),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatedCheckboxFromTaskBody,)
  }
);}




export const getUpdatedCheckboxFromTaskMutationOptions = <TError = UpdatedCheckboxFromTask404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatedCheckboxFromTask>>, TError,{data: UpdatedCheckboxFromTaskBody;params: UpdatedCheckboxFromTaskParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof updatedCheckboxFromTask>>, TError,{data: UpdatedCheckboxFromTaskBody;params: UpdatedCheckboxFromTaskParams}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatedCheckboxFromTask>>, {data: UpdatedCheckboxFromTaskBody;params: UpdatedCheckboxFromTaskParams}> = (props) => {
          const {data,params} = props ?? {};

          return  updatedCheckboxFromTask(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatedCheckboxFromTaskMutationResult = NonNullable<Awaited<ReturnType<typeof updatedCheckboxFromTask>>>
    export type UpdatedCheckboxFromTaskMutationBody = UpdatedCheckboxFromTaskBody
    export type UpdatedCheckboxFromTaskMutationError = UpdatedCheckboxFromTask404

    export const useUpdatedCheckboxFromTask = <TError = UpdatedCheckboxFromTask404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatedCheckboxFromTask>>, TError,{data: UpdatedCheckboxFromTaskBody;params: UpdatedCheckboxFromTaskParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof updatedCheckboxFromTask>>,
        TError,
        {data: UpdatedCheckboxFromTaskBody;params: UpdatedCheckboxFromTaskParams},
        TContext
      > => {

      const mutationOptions = getUpdatedCheckboxFromTaskMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
