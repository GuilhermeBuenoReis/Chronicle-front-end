/**
 * Generated by orval v7.3.0 üç∫
 * Do not edit manually.
 * in-orbit
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import { http } from '../client';
export type DeleteTaskById400 = {
  message: string;
};

export type DeleteTaskById200 = {
  message: string;
};

export type DeleteTaskByIdParams = {
id: string;
};

export type UpdatedTask404 = {
  message: string;
};

export type UpdatedTask201UpdatedTask = {
  content: string;
  createAt: string;
  id: string;
  /** @nullable */
  is_completed: boolean | null;
  title: string;
};

export type UpdatedTask201 = {
  updatedTask: UpdatedTask201UpdatedTask;
};

export type UpdatedTaskBody = {
  content?: string;
  is_completed?: boolean;
  title?: string;
};

export type UpdatedTaskParams = {
id: string;
};

export type GetTasksRoute200Item = {
  content: string;
  createAt: string;
  id: string;
  /** @nullable */
  is_completed: boolean | null;
  title: string;
};

export type CreateTask201 = {
  message: string;
};

export type CreateTaskBody = {
  content: string;
  is_completed: boolean;
  title: string;
  userId: string;
};

export type DeleteNoteById400 = {
  message: string;
};

export type DeleteNoteById200 = {
  message: string;
};

export type DeleteNoteByIdParams = {
id: string;
};

export type UpdatedNote404 = {
  message: string;
};

export type UpdatedNote201UpdatedNote = {
  content: string;
  createdAt: string;
  id: string;
  /** @nullable */
  tags: string | null;
  title: string;
};

export type UpdatedNote201 = {
  updatedNote: UpdatedNote201UpdatedNote;
};

export type UpdatedNoteBody = {
  content?: string;
  tags?: string;
  title?: string;
};

export type UpdatedNoteParams = {
id: string;
};

export type FindNotesById404 = {
  message: string;
};

export type FindNotesById200Note = {
  content: string;
  createdAt: string;
  id: string;
  /** @nullable */
  tags: string | null;
  title: string;
};

export type FindNotesById200 = {
  note: FindNotesById200Note;
};

export type FindNotesByIdParams = {
id: string;
};

export type FindNotesByTags404 = {
  message: string;
};

export type FindNotesByTags200NoteItem = {
  content: string;
  createdAt: string;
  id: string;
  tag: string;
  title: string;
};

export type FindNotesByTags200 = {
  note: FindNotesByTags200NoteItem[];
};

export type FindNotesByTagsBody = {
  tags: string;
};

export type GetNotesRoute200Item = {
  content: string;
  createdAt: string;
  id: string;
  /** @nullable */
  tags: string | null;
  title: string;
};

/**
 * @nullable
 */
export type CreateNote201 = typeof CreateNote201[keyof typeof CreateNote201] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateNote201 = {
  null: 'null',
} as const;

export type CreateNoteBody = {
  content: string;
  folderId?: string;
  tags?: string;
  title: string;
  userId: string;
};

export type AuthenticateUserRoute201 = {
  token: string;
};

export type AuthenticateUserRouteBody = {
  email: string;
  password: string;
};

/**
 * @nullable
 */
export type GetUserByEmailAndPassword201 = typeof GetUserByEmailAndPassword201[keyof typeof GetUserByEmailAndPassword201] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUserByEmailAndPassword201 = {
  null: 'null',
} as const;

export type GetUserByEmailAndPasswordBody = {
  email: string;
  password: string;
};

/**
 * @nullable
 */
export type CreateUser201 = typeof CreateUser201[keyof typeof CreateUser201] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateUser201 = {
  null: 'null',
} as const;

export type CreateUserBody = {
  avatarUrl: string;
  email: string;
  name: string;
  password: string;
};

/**
 * @nullable
 */
export type CreateFolders201 = typeof CreateFolders201[keyof typeof CreateFolders201] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateFolders201 = {
  null: 'null',
} as const;

export type CreateFoldersBody = {
  name: string;
  userId: string;
};

export type GetUserLevelAndExperience200 = {
  experience: number;
  experienceToNextLevel: number;
  level: number;
};

export type GetProfile200Profile = {
  avatarUrl: string;
  /** @nullable */
  email: string | null;
  id: string;
  /** @nullable */
  name: string | null;
};

export type GetProfile200 = {
  profile: GetProfile200Profile;
};

export type AuthenticateFromGithub201 = {
  token: string;
};

export type AuthenticateFromGithubBody = {
  code: string;
};

export type GetWeekSummary200SummaryGoalsPerDayItem = {
  completedAt: string;
  id: string;
  title: string;
};

/**
 * @nullable
 */
export type GetWeekSummary200SummaryGoalsPerDay = {[key: string]: GetWeekSummary200SummaryGoalsPerDayItem[]} | null;

export type GetWeekSummary200Summary = {
  completed: number;
  /** @nullable */
  goalsPerDay: GetWeekSummary200SummaryGoalsPerDay;
  /** @nullable */
  total: number | null;
};

export type GetWeekSummary200 = {
  summary: GetWeekSummary200Summary;
};

export type GetWeekSummaryParams = {
weekStartsAt?: string;
};

export type GetWeekPendingGoals200PendingGoalsItem = {
  completionCount: number;
  desiredWeeklyFrequency: number;
  id: string;
  title: string;
};

export type GetWeekPendingGoals200 = {
  pendingGoals: GetWeekPendingGoals200PendingGoalsItem[];
};

/**
 * @nullable
 */
export type CreateGoalCompletion201 = typeof CreateGoalCompletion201[keyof typeof CreateGoalCompletion201] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateGoalCompletion201 = {
  null: 'null',
} as const;

export type CreateGoalCompletionBody = {
  goalId: string;
};

/**
 * @nullable
 */
export type CreateGoals201 = typeof CreateGoals201[keyof typeof CreateGoals201] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateGoals201 = {
  null: 'null',
} as const;

export type CreateGoalsBody = {
  /**
   * @minimum 1
   * @maximum 7
   */
  desiredWeeklyFrequency: number;
  title: string;
};




type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


/**
 * Create a goal
 */
export const getCreateGoalsUrl = () => {


  return `http://localhost:3333/goals`
}

export const createGoals = async (createGoalsBody: CreateGoalsBody, options?: RequestInit): Promise<CreateGoals201> => {
  
  return http<Promise<CreateGoals201>>(getCreateGoalsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createGoalsBody,)
  }
);}




export const getCreateGoalsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGoals>>, TError,{data: CreateGoalsBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createGoals>>, TError,{data: CreateGoalsBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createGoals>>, {data: CreateGoalsBody}> = (props) => {
          const {data} = props ?? {};

          return  createGoals(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateGoalsMutationResult = NonNullable<Awaited<ReturnType<typeof createGoals>>>
    export type CreateGoalsMutationBody = CreateGoalsBody
    export type CreateGoalsMutationError = unknown

    export const useCreateGoals = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGoals>>, TError,{data: CreateGoalsBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof createGoals>>,
        TError,
        {data: CreateGoalsBody},
        TContext
      > => {

      const mutationOptions = getCreateGoalsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Complete a goal
 */
export const getCreateGoalCompletionUrl = () => {


  return `http://localhost:3333/completions`
}

export const createGoalCompletion = async (createGoalCompletionBody: CreateGoalCompletionBody, options?: RequestInit): Promise<CreateGoalCompletion201> => {
  
  return http<Promise<CreateGoalCompletion201>>(getCreateGoalCompletionUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createGoalCompletionBody,)
  }
);}




export const getCreateGoalCompletionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGoalCompletion>>, TError,{data: CreateGoalCompletionBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createGoalCompletion>>, TError,{data: CreateGoalCompletionBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createGoalCompletion>>, {data: CreateGoalCompletionBody}> = (props) => {
          const {data} = props ?? {};

          return  createGoalCompletion(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateGoalCompletionMutationResult = NonNullable<Awaited<ReturnType<typeof createGoalCompletion>>>
    export type CreateGoalCompletionMutationBody = CreateGoalCompletionBody
    export type CreateGoalCompletionMutationError = unknown

    export const useCreateGoalCompletion = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGoalCompletion>>, TError,{data: CreateGoalCompletionBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof createGoalCompletion>>,
        TError,
        {data: CreateGoalCompletionBody},
        TContext
      > => {

      const mutationOptions = getCreateGoalCompletionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get pending goals
 */
export const getGetWeekPendingGoalsUrl = () => {


  return `http://localhost:3333/pending-goals`
}

export const getWeekPendingGoals = async ( options?: RequestInit): Promise<GetWeekPendingGoals200> => {
  
  return http<Promise<GetWeekPendingGoals200>>(getGetWeekPendingGoalsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetWeekPendingGoalsQueryKey = () => {
    return [`http://localhost:3333/pending-goals`] as const;
    }

    
export const getGetWeekPendingGoalsQueryOptions = <TData = Awaited<ReturnType<typeof getWeekPendingGoals>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekPendingGoals>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWeekPendingGoalsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekPendingGoals>>> = ({ signal }) => getWeekPendingGoals({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWeekPendingGoals>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWeekPendingGoalsQueryResult = NonNullable<Awaited<ReturnType<typeof getWeekPendingGoals>>>
export type GetWeekPendingGoalsQueryError = unknown


export function useGetWeekPendingGoals<TData = Awaited<ReturnType<typeof getWeekPendingGoals>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekPendingGoals>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekPendingGoals>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWeekPendingGoals<TData = Awaited<ReturnType<typeof getWeekPendingGoals>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekPendingGoals>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekPendingGoals>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWeekPendingGoals<TData = Awaited<ReturnType<typeof getWeekPendingGoals>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekPendingGoals>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetWeekPendingGoals<TData = Awaited<ReturnType<typeof getWeekPendingGoals>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekPendingGoals>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWeekPendingGoalsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get week summary goals
 */
export const getGetWeekSummaryUrl = (params?: GetWeekSummaryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:3333/summary?${normalizedParams.toString()}` : `http://localhost:3333/summary`
}

export const getWeekSummary = async (params?: GetWeekSummaryParams, options?: RequestInit): Promise<GetWeekSummary200> => {
  
  return http<Promise<GetWeekSummary200>>(getGetWeekSummaryUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetWeekSummaryQueryKey = (params?: GetWeekSummaryParams,) => {
    return [`http://localhost:3333/summary`, ...(params ? [params]: [])] as const;
    }

    
export const getGetWeekSummaryQueryOptions = <TData = Awaited<ReturnType<typeof getWeekSummary>>, TError = unknown>(params?: GetWeekSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSummary>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWeekSummaryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekSummary>>> = ({ signal }) => getWeekSummary(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWeekSummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWeekSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof getWeekSummary>>>
export type GetWeekSummaryQueryError = unknown


export function useGetWeekSummary<TData = Awaited<ReturnType<typeof getWeekSummary>>, TError = unknown>(
 params: undefined |  GetWeekSummaryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSummary>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWeekSummary<TData = Awaited<ReturnType<typeof getWeekSummary>>, TError = unknown>(
 params?: GetWeekSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekSummary>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWeekSummary<TData = Awaited<ReturnType<typeof getWeekSummary>>, TError = unknown>(
 params?: GetWeekSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSummary>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetWeekSummary<TData = Awaited<ReturnType<typeof getWeekSummary>>, TError = unknown>(
 params?: GetWeekSummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekSummary>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWeekSummaryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Authenticate user from Gitub code
 */
export const getAuthenticateFromGithubUrl = () => {


  return `http://localhost:3333/auth/github`
}

export const authenticateFromGithub = async (authenticateFromGithubBody: AuthenticateFromGithubBody, options?: RequestInit): Promise<AuthenticateFromGithub201> => {
  
  return http<Promise<AuthenticateFromGithub201>>(getAuthenticateFromGithubUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authenticateFromGithubBody,)
  }
);}




export const getAuthenticateFromGithubMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticateFromGithub>>, TError,{data: AuthenticateFromGithubBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof authenticateFromGithub>>, TError,{data: AuthenticateFromGithubBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticateFromGithub>>, {data: AuthenticateFromGithubBody}> = (props) => {
          const {data} = props ?? {};

          return  authenticateFromGithub(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticateFromGithubMutationResult = NonNullable<Awaited<ReturnType<typeof authenticateFromGithub>>>
    export type AuthenticateFromGithubMutationBody = AuthenticateFromGithubBody
    export type AuthenticateFromGithubMutationError = unknown

    export const useAuthenticateFromGithub = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticateFromGithub>>, TError,{data: AuthenticateFromGithubBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof authenticateFromGithub>>,
        TError,
        {data: AuthenticateFromGithubBody},
        TContext
      > => {

      const mutationOptions = getAuthenticateFromGithubMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get user profile
 */
export const getGetProfileUrl = () => {


  return `http://localhost:3333/profile`
}

export const getProfile = async ( options?: RequestInit): Promise<GetProfile200> => {
  
  return http<Promise<GetProfile200>>(getGetProfileUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetProfileQueryKey = () => {
    return [`http://localhost:3333/profile`] as const;
    }

    
export const getGetProfileQueryOptions = <TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProfileQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProfile>>> = ({ signal }) => getProfile({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProfileQueryResult = NonNullable<Awaited<ReturnType<typeof getProfile>>>
export type GetProfileQueryError = unknown


export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProfileQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get user experience and level
 */
export const getGetUserLevelAndExperienceUrl = () => {


  return `http://localhost:3333/profile/gamification`
}

export const getUserLevelAndExperience = async ( options?: RequestInit): Promise<GetUserLevelAndExperience200> => {
  
  return http<Promise<GetUserLevelAndExperience200>>(getGetUserLevelAndExperienceUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetUserLevelAndExperienceQueryKey = () => {
    return [`http://localhost:3333/profile/gamification`] as const;
    }

    
export const getGetUserLevelAndExperienceQueryOptions = <TData = Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserLevelAndExperienceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserLevelAndExperience>>> = ({ signal }) => getUserLevelAndExperience({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserLevelAndExperienceQueryResult = NonNullable<Awaited<ReturnType<typeof getUserLevelAndExperience>>>
export type GetUserLevelAndExperienceQueryError = unknown


export function useGetUserLevelAndExperience<TData = Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserLevelAndExperience>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserLevelAndExperience<TData = Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserLevelAndExperience>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserLevelAndExperience<TData = Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUserLevelAndExperience<TData = Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserLevelAndExperience>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUserLevelAndExperienceQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a folder
 */
export const getCreateFoldersUrl = () => {


  return `http://localhost:3333/folder`
}

export const createFolders = async (createFoldersBody: CreateFoldersBody, options?: RequestInit): Promise<CreateFolders201> => {
  
  return http<Promise<CreateFolders201>>(getCreateFoldersUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createFoldersBody,)
  }
);}




export const getCreateFoldersMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFolders>>, TError,{data: CreateFoldersBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createFolders>>, TError,{data: CreateFoldersBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createFolders>>, {data: CreateFoldersBody}> = (props) => {
          const {data} = props ?? {};

          return  createFolders(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateFoldersMutationResult = NonNullable<Awaited<ReturnType<typeof createFolders>>>
    export type CreateFoldersMutationBody = CreateFoldersBody
    export type CreateFoldersMutationError = unknown

    export const useCreateFolders = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFolders>>, TError,{data: CreateFoldersBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof createFolders>>,
        TError,
        {data: CreateFoldersBody},
        TContext
      > => {

      const mutationOptions = getCreateFoldersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Create a folder
 */
export const getCreateUserUrl = () => {


  return `http://localhost:3333/user`
}

export const createUser = async (createUserBody: CreateUserBody, options?: RequestInit): Promise<CreateUser201> => {
  
  return http<Promise<CreateUser201>>(getCreateUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUserBody,)
  }
);}




export const getCreateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: CreateUserBody}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = CreateUserBody
    export type CreateUserMutationError = unknown

    export const useCreateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {data: CreateUserBody},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get user by email and passowrd
 */
export const getGetUserByEmailAndPasswordUrl = () => {


  return `http://localhost:3333/auth/find`
}

export const getUserByEmailAndPassword = async (getUserByEmailAndPasswordBody: GetUserByEmailAndPasswordBody, options?: RequestInit): Promise<GetUserByEmailAndPassword201> => {
  
  return http<Promise<GetUserByEmailAndPassword201>>(getGetUserByEmailAndPasswordUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      getUserByEmailAndPasswordBody,)
  }
);}




export const getGetUserByEmailAndPasswordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getUserByEmailAndPassword>>, TError,{data: GetUserByEmailAndPasswordBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof getUserByEmailAndPassword>>, TError,{data: GetUserByEmailAndPasswordBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getUserByEmailAndPassword>>, {data: GetUserByEmailAndPasswordBody}> = (props) => {
          const {data} = props ?? {};

          return  getUserByEmailAndPassword(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetUserByEmailAndPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof getUserByEmailAndPassword>>>
    export type GetUserByEmailAndPasswordMutationBody = GetUserByEmailAndPasswordBody
    export type GetUserByEmailAndPasswordMutationError = unknown

    export const useGetUserByEmailAndPassword = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getUserByEmailAndPassword>>, TError,{data: GetUserByEmailAndPasswordBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof getUserByEmailAndPassword>>,
        TError,
        {data: GetUserByEmailAndPasswordBody},
        TContext
      > => {

      const mutationOptions = getGetUserByEmailAndPasswordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Authenticate user
 */
export const getAuthenticateUserRouteUrl = () => {


  return `http://localhost:3333/auth/authenticate`
}

export const authenticateUserRoute = async (authenticateUserRouteBody: AuthenticateUserRouteBody, options?: RequestInit): Promise<AuthenticateUserRoute201> => {
  
  return http<Promise<AuthenticateUserRoute201>>(getAuthenticateUserRouteUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authenticateUserRouteBody,)
  }
);}




export const getAuthenticateUserRouteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticateUserRoute>>, TError,{data: AuthenticateUserRouteBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof authenticateUserRoute>>, TError,{data: AuthenticateUserRouteBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticateUserRoute>>, {data: AuthenticateUserRouteBody}> = (props) => {
          const {data} = props ?? {};

          return  authenticateUserRoute(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticateUserRouteMutationResult = NonNullable<Awaited<ReturnType<typeof authenticateUserRoute>>>
    export type AuthenticateUserRouteMutationBody = AuthenticateUserRouteBody
    export type AuthenticateUserRouteMutationError = unknown

    export const useAuthenticateUserRoute = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticateUserRoute>>, TError,{data: AuthenticateUserRouteBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof authenticateUserRoute>>,
        TError,
        {data: AuthenticateUserRouteBody},
        TContext
      > => {

      const mutationOptions = getAuthenticateUserRouteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Create a folder
 */
export const getCreateNoteUrl = () => {


  return `http://localhost:3333/note`
}

export const createNote = async (createNoteBody: CreateNoteBody, options?: RequestInit): Promise<CreateNote201> => {
  
  return http<Promise<CreateNote201>>(getCreateNoteUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createNoteBody,)
  }
);}




export const getCreateNoteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNote>>, TError,{data: CreateNoteBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createNote>>, TError,{data: CreateNoteBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNote>>, {data: CreateNoteBody}> = (props) => {
          const {data} = props ?? {};

          return  createNote(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateNoteMutationResult = NonNullable<Awaited<ReturnType<typeof createNote>>>
    export type CreateNoteMutationBody = CreateNoteBody
    export type CreateNoteMutationError = unknown

    export const useCreateNote = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNote>>, TError,{data: CreateNoteBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof createNote>>,
        TError,
        {data: CreateNoteBody},
        TContext
      > => {

      const mutationOptions = getCreateNoteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get week summary notes
 */
export const getGetNotesRouteUrl = () => {


  return `http://localhost:3333/notes/summary`
}

export const getNotesRoute = async ( options?: RequestInit): Promise<GetNotesRoute200Item[]> => {
  
  return http<Promise<GetNotesRoute200Item[]>>(getGetNotesRouteUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetNotesRouteQueryKey = () => {
    return [`http://localhost:3333/notes/summary`] as const;
    }

    
export const getGetNotesRouteQueryOptions = <TData = Awaited<ReturnType<typeof getNotesRoute>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotesRoute>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNotesRouteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotesRoute>>> = ({ signal }) => getNotesRoute({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNotesRoute>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNotesRouteQueryResult = NonNullable<Awaited<ReturnType<typeof getNotesRoute>>>
export type GetNotesRouteQueryError = unknown


export function useGetNotesRoute<TData = Awaited<ReturnType<typeof getNotesRoute>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotesRoute>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotesRoute>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNotesRoute<TData = Awaited<ReturnType<typeof getNotesRoute>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotesRoute>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotesRoute>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNotesRoute<TData = Awaited<ReturnType<typeof getNotesRoute>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotesRoute>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetNotesRoute<TData = Awaited<ReturnType<typeof getNotesRoute>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotesRoute>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNotesRouteQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get user by email and passowrd
 */
export const getFindNotesByTagsUrl = () => {


  return `http://localhost:3333/notes/find`
}

export const findNotesByTags = async (findNotesByTagsBody: FindNotesByTagsBody, options?: RequestInit): Promise<FindNotesByTags200> => {
  
  return http<Promise<FindNotesByTags200>>(getFindNotesByTagsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      findNotesByTagsBody,)
  }
);}




export const getFindNotesByTagsMutationOptions = <TError = FindNotesByTags404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof findNotesByTags>>, TError,{data: FindNotesByTagsBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof findNotesByTags>>, TError,{data: FindNotesByTagsBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof findNotesByTags>>, {data: FindNotesByTagsBody}> = (props) => {
          const {data} = props ?? {};

          return  findNotesByTags(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FindNotesByTagsMutationResult = NonNullable<Awaited<ReturnType<typeof findNotesByTags>>>
    export type FindNotesByTagsMutationBody = FindNotesByTagsBody
    export type FindNotesByTagsMutationError = FindNotesByTags404

    export const useFindNotesByTags = <TError = FindNotesByTags404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof findNotesByTags>>, TError,{data: FindNotesByTagsBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof findNotesByTags>>,
        TError,
        {data: FindNotesByTagsBody},
        TContext
      > => {

      const mutationOptions = getFindNotesByTagsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Find notes by id
 */
export const getFindNotesByIdUrl = (id: string,
    params: FindNotesByIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:3333/notes/${id}?${normalizedParams.toString()}` : `http://localhost:3333/notes/${id}`
}

export const findNotesById = async (id: string,
    params: FindNotesByIdParams, options?: RequestInit): Promise<FindNotesById200> => {
  
  return http<Promise<FindNotesById200>>(getFindNotesByIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getFindNotesByIdQueryKey = (id: string,
    params: FindNotesByIdParams,) => {
    return [`http://localhost:3333/notes/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const getFindNotesByIdQueryOptions = <TData = Awaited<ReturnType<typeof findNotesById>>, TError = FindNotesById404>(id: string,
    params: FindNotesByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findNotesById>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindNotesByIdQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findNotesById>>> = ({ signal }) => findNotesById(id,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findNotesById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type FindNotesByIdQueryResult = NonNullable<Awaited<ReturnType<typeof findNotesById>>>
export type FindNotesByIdQueryError = FindNotesById404


export function useFindNotesById<TData = Awaited<ReturnType<typeof findNotesById>>, TError = FindNotesById404>(
 id: string,
    params: FindNotesByIdParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findNotesById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findNotesById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useFindNotesById<TData = Awaited<ReturnType<typeof findNotesById>>, TError = FindNotesById404>(
 id: string,
    params: FindNotesByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findNotesById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findNotesById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useFindNotesById<TData = Awaited<ReturnType<typeof findNotesById>>, TError = FindNotesById404>(
 id: string,
    params: FindNotesByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findNotesById>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useFindNotesById<TData = Awaited<ReturnType<typeof findNotesById>>, TError = FindNotesById404>(
 id: string,
    params: FindNotesByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findNotesById>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getFindNotesByIdQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * updated note
 */
export const getUpdatedNoteUrl = (id: string,
    params: UpdatedNoteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:3333/notes/update/${id}?${normalizedParams.toString()}` : `http://localhost:3333/notes/update/${id}`
}

export const updatedNote = async (id: string,
    updatedNoteBody: UpdatedNoteBody,
    params: UpdatedNoteParams, options?: RequestInit): Promise<UpdatedNote201> => {
  
  return http<Promise<UpdatedNote201>>(getUpdatedNoteUrl(id,params),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatedNoteBody,)
  }
);}




export const getUpdatedNoteMutationOptions = <TError = UpdatedNote404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatedNote>>, TError,{id: string;data: UpdatedNoteBody;params: UpdatedNoteParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof updatedNote>>, TError,{id: string;data: UpdatedNoteBody;params: UpdatedNoteParams}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatedNote>>, {id: string;data: UpdatedNoteBody;params: UpdatedNoteParams}> = (props) => {
          const {id,data,params} = props ?? {};

          return  updatedNote(id,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatedNoteMutationResult = NonNullable<Awaited<ReturnType<typeof updatedNote>>>
    export type UpdatedNoteMutationBody = UpdatedNoteBody
    export type UpdatedNoteMutationError = UpdatedNote404

    export const useUpdatedNote = <TError = UpdatedNote404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatedNote>>, TError,{id: string;data: UpdatedNoteBody;params: UpdatedNoteParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof updatedNote>>,
        TError,
        {id: string;data: UpdatedNoteBody;params: UpdatedNoteParams},
        TContext
      > => {

      const mutationOptions = getUpdatedNoteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get pending goals
 */
export const getDeleteNoteByIdUrl = (id: string,
    params: DeleteNoteByIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:3333/notes/delete/${id}?${normalizedParams.toString()}` : `http://localhost:3333/notes/delete/${id}`
}

export const deleteNoteById = async (id: string,
    params: DeleteNoteByIdParams, options?: RequestInit): Promise<DeleteNoteById200> => {
  
  return http<Promise<DeleteNoteById200>>(getDeleteNoteByIdUrl(id,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteNoteByIdMutationOptions = <TError = DeleteNoteById400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNoteById>>, TError,{id: string;params: DeleteNoteByIdParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNoteById>>, TError,{id: string;params: DeleteNoteByIdParams}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteNoteById>>, {id: string;params: DeleteNoteByIdParams}> = (props) => {
          const {id,params} = props ?? {};

          return  deleteNoteById(id,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteNoteByIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNoteById>>>
    
    export type DeleteNoteByIdMutationError = DeleteNoteById400

    export const useDeleteNoteById = <TError = DeleteNoteById400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNoteById>>, TError,{id: string;params: DeleteNoteByIdParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteNoteById>>,
        TError,
        {id: string;params: DeleteNoteByIdParams},
        TContext
      > => {

      const mutationOptions = getDeleteNoteByIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Create a task
 */
export const getCreateTaskUrl = () => {


  return `http://localhost:3333/task`
}

export const createTask = async (createTaskBody: CreateTaskBody, options?: RequestInit): Promise<CreateTask201> => {
  
  return http<Promise<CreateTask201>>(getCreateTaskUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createTaskBody,)
  }
);}




export const getCreateTaskMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTask>>, TError,{data: CreateTaskBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof createTask>>, TError,{data: CreateTaskBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTask>>, {data: CreateTaskBody}> = (props) => {
          const {data} = props ?? {};

          return  createTask(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTaskMutationResult = NonNullable<Awaited<ReturnType<typeof createTask>>>
    export type CreateTaskMutationBody = CreateTaskBody
    export type CreateTaskMutationError = unknown

    export const useCreateTask = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTask>>, TError,{data: CreateTaskBody}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof createTask>>,
        TError,
        {data: CreateTaskBody},
        TContext
      > => {

      const mutationOptions = getCreateTaskMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get tasks
 */
export const getGetTasksRouteUrl = () => {


  return `http://localhost:3333/task/summary`
}

export const getTasksRoute = async ( options?: RequestInit): Promise<GetTasksRoute200Item[]> => {
  
  return http<Promise<GetTasksRoute200Item[]>>(getGetTasksRouteUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetTasksRouteQueryKey = () => {
    return [`http://localhost:3333/task/summary`] as const;
    }

    
export const getGetTasksRouteQueryOptions = <TData = Awaited<ReturnType<typeof getTasksRoute>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTasksRoute>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTasksRouteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTasksRoute>>> = ({ signal }) => getTasksRoute({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTasksRoute>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTasksRouteQueryResult = NonNullable<Awaited<ReturnType<typeof getTasksRoute>>>
export type GetTasksRouteQueryError = unknown


export function useGetTasksRoute<TData = Awaited<ReturnType<typeof getTasksRoute>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTasksRoute>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTasksRoute>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTasksRoute<TData = Awaited<ReturnType<typeof getTasksRoute>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTasksRoute>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTasksRoute>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTasksRoute<TData = Awaited<ReturnType<typeof getTasksRoute>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTasksRoute>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTasksRoute<TData = Awaited<ReturnType<typeof getTasksRoute>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTasksRoute>>, TError, TData>>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTasksRouteQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * updated task
 */
export const getUpdatedTaskUrl = (id: string,
    params: UpdatedTaskParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:3333/task/update/${id}?${normalizedParams.toString()}` : `http://localhost:3333/task/update/${id}`
}

export const updatedTask = async (id: string,
    updatedTaskBody: UpdatedTaskBody,
    params: UpdatedTaskParams, options?: RequestInit): Promise<UpdatedTask201> => {
  
  return http<Promise<UpdatedTask201>>(getUpdatedTaskUrl(id,params),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatedTaskBody,)
  }
);}




export const getUpdatedTaskMutationOptions = <TError = UpdatedTask404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatedTask>>, TError,{id: string;data: UpdatedTaskBody;params: UpdatedTaskParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof updatedTask>>, TError,{id: string;data: UpdatedTaskBody;params: UpdatedTaskParams}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatedTask>>, {id: string;data: UpdatedTaskBody;params: UpdatedTaskParams}> = (props) => {
          const {id,data,params} = props ?? {};

          return  updatedTask(id,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatedTaskMutationResult = NonNullable<Awaited<ReturnType<typeof updatedTask>>>
    export type UpdatedTaskMutationBody = UpdatedTaskBody
    export type UpdatedTaskMutationError = UpdatedTask404

    export const useUpdatedTask = <TError = UpdatedTask404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatedTask>>, TError,{id: string;data: UpdatedTaskBody;params: UpdatedTaskParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof updatedTask>>,
        TError,
        {id: string;data: UpdatedTaskBody;params: UpdatedTaskParams},
        TContext
      > => {

      const mutationOptions = getUpdatedTaskMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete task
 */
export const getDeleteTaskByIdUrl = (id: string,
    params: DeleteTaskByIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:3333/task/delete/${id}?${normalizedParams.toString()}` : `http://localhost:3333/task/delete/${id}`
}

export const deleteTaskById = async (id: string,
    params: DeleteTaskByIdParams, options?: RequestInit): Promise<DeleteTaskById200> => {
  
  return http<Promise<DeleteTaskById200>>(getDeleteTaskByIdUrl(id,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteTaskByIdMutationOptions = <TError = DeleteTaskById400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTaskById>>, TError,{id: string;params: DeleteTaskByIdParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTaskById>>, TError,{id: string;params: DeleteTaskByIdParams}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTaskById>>, {id: string;params: DeleteTaskByIdParams}> = (props) => {
          const {id,params} = props ?? {};

          return  deleteTaskById(id,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTaskByIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTaskById>>>
    
    export type DeleteTaskByIdMutationError = DeleteTaskById400

    export const useDeleteTaskById = <TError = DeleteTaskById400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTaskById>>, TError,{id: string;params: DeleteTaskByIdParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteTaskById>>,
        TError,
        {id: string;params: DeleteTaskByIdParams},
        TContext
      > => {

      const mutationOptions = getDeleteTaskByIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
